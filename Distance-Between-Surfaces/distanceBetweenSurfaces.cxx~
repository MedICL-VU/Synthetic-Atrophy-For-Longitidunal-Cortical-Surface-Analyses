#include <iostream>
#include <string>
#include <math.h>
#include <cmath>

#include "vtkSmartPointer.h"
#include "vtkPolyData.h"
#include "vtkXMLPolyDataReader.h"
#include "vtkXMLPolyDataWriter.h"
#include "vtkPoints.h"
#include "vtkPointData.h"
#include "vtkCellLocator.h"
#include "vtkCellArray.h"
#include "vtkDoubleArray.h"
#include "vtkIdList.h"
#include "vtkFloatArray.h"
#include "vtkDataArray.h"
#include "vtkPolyDataNormals.h"
#include "vtkDistancePolyDataFilter.h"



// Initialize
const unsigned int nDims = 3;


// Function:  read polydata
vtkSmartPointer<vtkPolyData> ReadPolyData(std::string filename) {
  vtkSmartPointer<vtkXMLPolyDataReader> reader = vtkSmartPointer<vtkXMLPolyDataReader>::New();
  reader->SetFileName(filename.c_str());
  reader->Update();

  return reader->GetOutput();
}


// Function:  write polydata
void WritePolyData(vtkSmartPointer<vtkPolyData> mesh, std::string filename) {
  vtkSmartPointer<vtkXMLPolyDataWriter> writer = vtkSmartPointer<vtkXMLPolyDataWriter>::New();
  writer->SetInputData(mesh);
  writer->SetFileName(filename.c_str());
  writer->Write();
}



// Main
int main(int argc, char * argv[]) {

  if( argc < 3 ) {
    std::cerr << "Usage: " << std::endl;
    std::cerr << "OriginalSurface WarpedSurface OutputSurface" << std::endl;
    return -1;
  }

  
  // Read in ze data
  std::string inputPolyDataFileName_original = argv[1];
  std::string inputPolyDataFileName_warped = argv[2];
  std::string outputPolyDataFileName = argv[3];
  
  vtkSmartPointer<vtkPolyData> originalMesh = ReadPolyData(inputPolyDataFileName_original);
  vtkSmartPointer<vtkPolyData> warpedMesh = ReadPolyData(inputPolyDataFileName_warped);
  unsigned int nPts = originalMesh->GetPoints()->GetNumberOfPoints();


  // Calculate signed distance
  vtkSmartPointer<vtkDistancePolyDataFilter> distanceFilter = vtkSmartPointer<vtkDistancePolyDataFilter>::New();
  distanceFilter->SetInputData(0,originalMesh);
  distanceFilter->SetInputData(1,warpedMesh);
  distanceFilter->SignedDistanceOn();
  distanceFilter->Update();

  vtkSmartPointer<vtkDoubleArray> buffer = vtkDoubleArray::SafeDownCast(distanceFilter->GetOutput()->GetPointData()->GetArray("Distance"));
  vtkSmartPointer<vtkFloatArray> surfaceDistance = vtkSmartPointer<vtkFloatArray>::New();
  surfaceDistance->SetNumberOfComponents(1);
  surfaceDistance->SetNumberOfTuples(nPts);
  surfaceDistance->SetName("Surface-Distance");

  for(unsigned int p = 0; p < nPts; p++) {
    double distd[1];
    buffer->GetTuple(p,distd);
    float distf = distd[1];
    surfaceDistance->SetValue(p,distf);
  }


  // Get Distance (this is unsigned tho....)
  /*
  vtkSmartPointer<vtkFloatArray> surfaceDistance = vtkSmartPointer<vtkFloatArray>::New();
  surfaceDistance->SetNumberOfComponents(1);
  surfaceDistance->SetNumberOfTuples(nPts);
  surfaceDistance->SetName("Surface-Distance");

  vtkSmartPointer<vtkCellLocator> cellLocator = vtkSmartPointer<vtkCellLocator>::New();
  cellLocator->SetDataSet(warpedMesh);
  cellLocator->BuildLocator();

  for(unsigned int p = 0; p < nPts; p++) {
    double p0[nDims], p1[nDims];
    originalMesh->GetPoint(p,p0);
    
    double dist2;
    vtkIdType cellId;
    int subId;
    cellLocator->FindClosestPoint(p0,p1,cellId,subId,dist2);
    surfaceDistance->SetValue(p,std::sqrt(dist2));
  }
  */
  originalMesh->GetPointData()->AddArray(surfaceDistance);
  originalMesh->BuildLinks();

  WritePolyData(originalMesh,outputPolyDataFileName);     


  return 0;
}
